모든 경우의 수 확인
Greedy한 논리의 사용 불가.

`1원, 4원, 6원 동전을 이용하여 8원을 최소 갯수의 동전으로 만들기`

- 장점 : 반례를 생각할 필요가 없는 매우 단순한 문제 해결 방법.
- 단점 : 모든 경우의 수를 따져보기 위해 많은 연산량이 필요함.

 ## BFS, DFS
 - Tree나 Graph에서 모든 노드를 탐색하기 위한 탐색 알고리즘 중 하나.
 - 모든 경우의 수를 탐색하는 방법으로도 사용됨.

1. 노드 - 상태, root 노드 - 초기 상태, leaf 노드 - 목적 상태
2. 탐색 과정에서 자식 노드로의 이동의 의미.
3. Root Node에서 LeafNode까지의 경로 하나의 탐색
4. Tree 전체 노드의 탐색 의미.

# BFS (Breadth First Search) 탐색 전략
- 초기 상태에서부터 탐색 시작.
- FIFO Queue를 사용.

### BFS 기본 코드 형태
```
while(!Queue.Empty()) {
    Dequeue(current state);
    state calculate -> next state;
    Enqueue(next state);
}
```

### 중요 특징
1. 모든 경우의 수 동시 다발적으로 진행
2. FIFO Queue 이용하여 구현할 경우 모든 경우의 수가 평등하게 발전.

BFS/DFS 구현시 결정사항
- 상태 / 상태 발전 정의
- 경우의 수 가지치기 조건 계획.
-> BFS/DFS의 많은 연산량을 고려. (특히 BFS로 해결하는 문제의 경우 연산량이 매우 큼)
※ 최단 거리
- 가중치가 같은 경우 : 중복 방문x, 도착점에 도달하면 끝.
- 가중치가 다른 경우 : 중복 방문o, Queue가 Empty할때까지 iterate.

# DFS (Depth First Search) 탐색 전략
### ● 초기 상태에서부터 탐색 시작

### ● 상태 발전

- 다음 상태 생성시 바로 당므 상태로 상태 발전 진행
    - Tree의 Depth를 파고 들어가면서 탐색하는 것을 우선시 하는 전략.
- 현재 상태에서 발전시킬 수 있는 다음 상태 모두 발전 후, 이전 상태로 돌아가 상태 발전 진행.
    - 재귀함수 (Recommended)
    - Stack + 반복문


## DFS 기본 코드 형태
```
최초 탐색 시작 : DFS(초기 상태)
```
```
def DFS(현재 상태):
    if 현재 상태 == 목적 상태:
        return

    상태 발전 -> 다음 상태
    DFS(다음 상태)
```
- __return 문을 잘 두는 것이 중요함__

## DFS의 특징

- 모든 경우의 수 개별적으로 하나씩 발전
- 가지치기가 필요함. 경우의 수가 너무 많아지는 경우에 불펼요한 경우는 굳이 해보지 않기.

## BFS와 DFS의 비교
||DFS|BFS|
|:---:|:---:|:---:|
|상태 발전 전략|깊이 파고들기 우선|넓게 퍼뜨리기 우선|
|경우의 수 시도|개별 경우의 수 하나씩 발전|모든 경우의 수 동시다발적 평등|
|상태 저장 자료구조|Stack<br>(현재 진행 경우의 수 상태) | Queue<br>(모든 경우의 수 진행 상태 저장)|

## 경우의 수

### 순열 (Permutation)
: 서로 다른 n개 중에서 r개를 선택하여 일렬로 세우는 경우
- 중복 순열 -> ($6^n$)
- 순열 -> ($nPr$)
### 조합 (Combination)
: 서로 다른 n개 중에서 r개를 선택하여 그룹을 만드는 경우 (순서는 상관 없음) ex) 로또
- 중복 조합 -> ($nHr$)
- 조합 -> ($nCr$)



## 문제 해결 
- 합이 K가 되는 경우를 찾으면 다른 경우는 찾을 필요 없음 -> 리턴 필요 (성공 여부)
- Argument는 다중 트리 형태인 경우에는 시작 인덱스와 누적 합 (혹은 K 값에서 차감)
- 누적 합을 하는 것보다 차감해 나가는 방식이 유리
    - 누적 합이 변수의 저장 범위를 벗어나는 경우가 있으면 오 계산 발생함
    - 차감 해나가면 그런 경우 발생하지 않음.
- Argument는 이진 트리 형태인 경우에는 숫자 인덱스와 누적합 (혹은 K값에서 차감)
- 가지치기(branch & bound) 필요.
    - 모든 경우를 다 탐색하는 방식이므로 불필요한 탐색은 시도를 하지 않게 해서 성능 향상
    - 남은 숫자들을 모두 더해도 K를 만들 수 없다면 시도 불필요
    - 매회 남은 숫자들을 더해보는 건 숫자들이 많은 경우 시간이 많이 걸림.
    - 구간의 합을 빠르게 구하는 방법은 prefix sum table 방법 활용.
    `prefix sum table`
    - psum table을 누적해서 저장
    - (s~e) 구간의 합 : psum[e] - psum[s-1] -> loop를 이용해서 구간의 합을 구하지 않아도 됨.
    