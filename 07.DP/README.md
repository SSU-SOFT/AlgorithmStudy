# 동적계획법 (Dynamic Programming)
: 응용 수학자 리차드 벨만이 1953년에 고안한 알고리즘으로 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다. 다이나믹 프로그래밍 알고리즘을 이용하면, 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제, 즉 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있다. 중요한 점은 '중복된' 문제들이란 점이며, 중복되지 않는 문제들은 다이나믹 프로그래밍으로 풀지 않는다.

|알고리즘|풀이가능한 문제들의 특징|풀이 가능한 문제 및 알고리즘
|---|---|---|
|다이나믹 프로그래밍| - 최적 부분 구조<br/>- 중복된 하위 문제들 | - 0-1 배낭 문제<br/>- 피보나치 수열<br/>- 다익스트라 알고리즘
|그리디 알고리즘|- 최적 부분 구조<br/>- 탐욕 선택 속성|- 분할 가능 배낭 문제<br/>- 다익스트라 알고리즘
|분할 정복|- 최적 부분 구조|- 병합정렬<br/>- 퀵정렬

## 다이나믹 프로그래밍 방법론
: 방법론은 방식에 따라 크게 상향식과 하향식으로 나뉘며, 일반적으로 상향식을 타뷸레이션, 하향식을 메모이제이션이라고 구분해 부르기도 한다.

- `상향식(Bottom-Up)` : 더 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다. 타뷸레이션 Tabulation이라고 부르며, 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.

- `하향식(Top-Down)` : 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 플어나간다. 이 방식을 특별히 메모이제이션(Memoization)이라 지칭한다.

__피보나치 수열__


`상향식`
```
def fib(n):
    dp[0] = 0
    dp[1] = 1

    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```
`하향식`
```
def fib(n):
    if n <= 1:
        return n
    
    if dp[n]:
        return dp[n]
    
    dp[n] = fib(n-1) + fib(n-2)
    return dp[n]
```

 대부분의 다이나믹 프로그래밍 문제는 어렵기 때문에, 피보나치 수열과 0-1배낭 문제는 그중에서도 가장 기본이라 할 수 있는 문제이다. 비교적 많은 문제를 풀어서 감을 익히는 수밖에 없다.