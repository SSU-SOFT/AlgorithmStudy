# Database (데이터 베이스)
: 서로 연관되어 있는 데이터의 모임. 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이떄의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.

## 데이터베이스의 특징
1. __데이터의 독립성__
    - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
    - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용프로그램의 논리적 요구를 만족시켜줄 수 있다.

2. __데이터의 무결성__
: 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다. (트랜잭션)

3. __데이터의 보안성__
: 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

4. __데이터의 일관성__
: 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제 할 수 있다.

5. __데이터 중복 최소화__
: 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

## 관계형 데이터 베이스 (RDBMS)
: 테이블 기반으로 데이터를 저장하는 시스템이며, 정규화를 통해서 중복성을 제거한다.

__테이블(Table)__
- 행과 열로 이루어진 데이터의 집합.
- 일반적인 데이터베이스에서는 행과 열만 있으면 테이블이라고 하지만, 관계형 데이터베이스에서는 여기에 특별한 제약을 추가해서 `릴레이션`이라고 부른다.
- 모든 릴레이션은 테이블이지만, 모든 테이블이 릴레이션인건 아니다.

1. 모든 값은 유일한 값을 가진다.
2. 하나의 릴레이션에서 중복되는 행이 존재하면 안된다.

__행(Row)__
- 테이블을 구성하는 데이터중 가로로 묶은 데이터 셋을 의미한다.
- 일반적으로 행은 한 객체에 대한 정보를 가지고 있다.
- 관계형 데이터 베이스에서는 `튜플` 또는 `레코드`라는 이름으로 불린다.

__열(Column)__
- 테이블을 구성하는 데이터들 중 세로로 묶은 데이터셋을 의미한다.
- 일반적으로 열은 그 테이블의 속성을 의미하며 열을 구성하는 값들은 같은 `도메인`으로 되어 있다.
- 관계형 데이터 베이스에서는 `속성`이라는 이름으로 불린다.

__도메인(Domain)__
- 데이터베이스에서 필드에 채워질 수 있는 값의 집합이다.
- 도메인이 1에서 10사이의 정수인 속성의 필드에 11이나 -1처럼 도메인을 벗어나는 값 또는 '고양이'처럼 아예 자료형이 다른 값이 들어갈 수 없다.

__스키마(Schema)__
- 데이터베이스의 구조를 전반적으로 기술한 것을 말한다.
- 데이터베이스를 구성하는 데이터 레코드의 크기, 키의 정의, 레코드 간의 관계 등을 정의한 것을 말한다.
- 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 구분한다.
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 내부스키마 형태로 변환한다.

__외부 스키마__
- 사용자의 입장에서 정의한 데이터베이스의 논리적 구조
- 데이터들을 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인가에 대한 명세를 말하며 하나의 데이터베이스에는 여러 개의 외부 스키마가 있을 수 있다.
- 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해서 DB에 접근하도록 한다.

__개념 스키마__
- 조직체 전체를 관장하는 입장에서 DB를 정의한 스키마.
- DB에 대한 모든 논리적 구조를 기술하기 때문에 데이터베이스에 하나만 존재하며, 통상 스키마라고 하면 개념 스키마를 일컫는다.

__내부 스키마__
- 데이터베이스가 어떻게 저장 장치에 저장될 지에 대한 명세.
- 물리적인 저장 장치와 데이터베이스 간의 관계를 정의하므로 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마이다.

## 키(Key)

1. `후보키(Candidate Key)`
: Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합. 모든 릴레이션은 반드시 하나 이상의 후보 키를 가져야 한다.
- 유일성 : Key로 하나의 Tuple을 유일하게 식별 할 수 있음.
- 최소성 : 꼭 필요한 속성으로만 구성

2. `기본키(Primary Key)`
: 후보키 중 선택한 Main Key. 특정 튜플을 유일하게 구별할 수 있는 속성.Null 값을 가질 수 없음. 동일한 값이 중복될 수 없음.
- 유일성, 최소성.
- 개체 무결성 : 기본키가 가지고 있는 값의 유일성을 보장받아야 한다.

3. `대체키(Alternate Key)`
: 후보키 중 기본키를 제외한 나머지 키. 보조키 라고도 한다.

4. `슈퍼키(Super Key)`
: 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키. 유일성은 만족하지만, 최소성은 만족하지 못하는 키

5. `외래키(Foreign Key)`
: 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합. Join시 기준이 되는 컬럼.
- Foreign Key가 Primary Key인 경우 : 식별관계
- Foreign Key가 일반 컬럼인 경우 : 비식별관계

> 참조 무결성 제약 조건 (Referential Integrity)
> - 외래키로 연결되어 있는 테이블의 경우에는 외래키로 연결 테이블을 검색하면 데이터가 존재해야 함.
> - 삽입/삭제에 순서가 있어야 함.
-> 원 레코드를 삭제하려면 참조하는 레코드를 먼저 삭제해야 가능.
-> 외래키를 가진 레코드를 추가하려면, 연결테이블에 레코드를 먼저 추가해야 함.

## 인덱스(Index)
: 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.

DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 RDBMS에서 인덱스는 데이터의 저장성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 
만약 읽기보다 쓰기가 빈번한 시스템이라면 쓰기에 최적화된 NoSOL류를 사용해야 한다. 

최근에는 RDBMS와 NoSQL을 섞어서 지원하는 경우가 많다.

__인덱스 실습__
```
SHOW INDEXES FROM employees
CREATE INDEX sample_index ON employees (sample_col1, sample_col2)
```

__B+ Tree 인덱스 알고리즘__
:일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. 컬럼의 값을 변형하지 않고 (앞부분만 잘라서 관리한다.) 원래의 값을 이용해 인덱싱하는 알고리즘이다.

> B+트리
키에 의해서 각각 식별되는 레코드의 효율적인 삽입, 검색과 삭제를 통해 정렬된 데이터를 표현하기 위한 트리자료구조의 일종이다. 


__Hash 인덱스 알고리즘__
:컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱 하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

> 왜 index를 생성하는데 B Tree를 사용하는가?
데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 것 같지만, SELECT 질의 조건에는 부등호연산도 포함되기 때문에 hash table을 사용하게 된다면 문제가 발생한다.

__Composite Index__
인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 search 하는 경우 index 효과를 볼 수 있지만, author만 search 하는 경우 index의 효과를 볼 수 없다.

__Index의 성능과 고려해야할 사항__
INDEX를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT의 경우 INDEX에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE의 경우 INDEX에 존재하는 값은 삭제하지 않고 사용안한다는 표시로 남게된다. 즉, row의 수는 그대로인 것이다.

컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재한다는 것이다.

`이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며, 나이는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다. 이 경우 이름에 대해서만 인덱스를 생성하면 효율적이다.

## 정규화
### 1. 정규화의 유래
: 한 릴레이션에 여러 엔티티의 속성들을 혼합하게 되면 정보가 `중복 저장`되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 `갱신 이상(Abnormal)`이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어떤 것이 정확한지 알 수 없게 되기 때문에 이를 `해결`하기 위해 정규화 과정을 거치는 것이다.

__1-1. 갱신 이상에는 어떠한 것들이 있는가?__
- __삽입 이상(insertion anomalies)__
: `원하지 않는 자료가 삽입`된다든지, 삽입하는데 `자료가 부족해 삽입이 되지 않는` 문제점을 말한다.

- __삭제 이상(deletion anomalies)__
: 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 `원하지 않는 정보 손실`이 발생하는 문제점을 말한다.

- __수정(갱신) 이상(modification anomalies)__
: 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 `정확한 정보 파악이 되지 않는 문제점`을 말한다.


### 2. 정규화란?
관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, BCNF, 제 4 정규형, 제 5정규형등이 존재한다. 실질적으로 많이 사용되는 정규형은 제 3정규형과 BCNF 이며, 그 이상의 정규형은 실효성이 거의 없어 사용하지 않는다.

- __제 1 정규형(1NF)__ 
: Column이 오직 `원자값`만을 갖도록 테이블을 구성. 도메인의 모든 값이 원자값이면 제 1정규형이다.

<img src="./imgs/1NF.png"/>

- __제 2 정규형(2NF)__
: 제 1 정규형 중에서 모든 비주요 속성이 모든 후보키에 완전 의존적이어야 한다. 즉, Key Column과 나머지 일반 Column이 직접연관관계(직접 종속)만 가지도록 테이블 구성

<img src="./imgs/2NF.png"/>

- __제 3 정규형(3NF)__
: 제 2 정규형 중에서 비 주요 속성이 모든 후보 키에 이행적으로 의존적이지 않다면 제3 정규형이다. 즉, 일반 컬럼끼리 간접 연관관계(간접 종속)을 가지지 않도록 테이블 분리

<img src="./imgs/3NF.png"/>

- __BC(Boyce-Codd) 정규형(BCNF)__
: 모든 결정자가 후보키 집합에 속하게 테이블을 분리. 여러 후보키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 제 3 정규형에서 직접 종속을 이루는 key가 super key 이면 BCNF 정규형이 된다.

__어떠한 장점이 있는가?__
1. 데이터베이스 변경 시 이상 현상 제거 위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다.
2. 데이터베이스 구조 확장 시 재 디자인 최소화 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.
3. 사용자에게 데이터 모델을 더욱 의미있게 제공 정규화된 테이블들과 정규화된 테이블들 간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.

> 단점은 없나?
릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN)이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다.

## 트랜잭션(Transaction)

### 트랜잭션이란 무엇인가?
: 트랜잭션은 `작업의 완정성을 보장`해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

__트랜잭션과 Lock__
잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 잠금은 동시성을 제어하기 위한 기능이고, 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 트랜잭션은 하나의 논리적인 작업 셋중 하나의 쿼리가 있든 2개의 쿼리가 있든 관계없이 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.

__트랜잭션의 특성(ACID)__

`원자성(Atomicity)` : 만약 트랜잭션 중간에 어떠한 문제가 발생하는 경우 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되는 특성

`일관성(Consistency)` : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. (어디서 읽던 같은 값을 읽을 때)

`고립성(Isolation)` : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. ex) Read commited, Repeatable Read

`지속성(Durability)` : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

> MySQL에서 트랜잭션 지원여부가 스토리지 엔진에 따라 다르다.
MySQL = MySQL 클라이언트 
    + MySQL 서버
    [MySQL엔진 + 스토리지 엔진(SQL interface + Parser + Optimizer + Cache/Buffer)]

__스토리지 엔진__
- MyISAM : 트랜잭션 / 외래키 지원X, 테이블 락
- InnoDB : 트랜잭션 / 외래키 지원, 레코드 락, MVCC 지원
- Memory : 임시테이블 (InMemory DBMS), 트랜잭션 안정성 지원 X / 외래키 지원 X, 

__테이블 락__
- `글로벌 락(Global Lock)` : 특정한 명령이 수행되면 다른 모든 명령어가 수행이 정지.
- `테이블 락(Table Lock)` : 특정 트랜잭션이 해당 테이블을 수정하고 있으면, 다른 트랜잭션은 해당 테이블을 접근하지 못함.
- `레코드 락(Record Lock)` : 특정 트랜잭션이 해당 레코드를 수정하고 있으면, 다른 트랜잭션은 해당 레코드를 접근하지 못함.

__트랜잭션 격리 수준__
- `Read Uncommited`
    - commit여부와 관계 없이 현재 레코드 값을 리턴.
    - 가장 낮은 데이터 안정성 / 가장 높은 성능 / Dirty Read 현상 발생 가능
- `Read Commited`
    - commit된 마지막 값을 리턴. 일반적으로 가장 많이 사용하는 격리 수준.
    - Non-Reapeatable Read 현상 발생 : 동일한 트랜잭션 안에서 동일한 쿼리의 결과가 다른 경우 발생.
    - Undo Log로 commit/uncommit된 값 중 마지막 레코드 리턴.
    > Raw : 100->110->120->130->140->Return
    Return : 100->110->120->130->140->140
- `Repeatable Read`
    - 동일한 트랜잭션에서의 한 쿼리 값은 항상 일정함.
    - Phantom Read현상 발생 : 데이터 변경은 불가능 하지만 추가 / 삭제는 가능함.
    - 백업이나 복제와 같이 상대적으로 긴 트랜잭션에서 안정적인 실행 보장이 필요한 경우 사용.
    > Raw : 100->110->120->130->140->Return
    Return : 100->100->100->100->100->140 
- `Serialize`
    - 두 개의 트랜잭션이 동시에 수행되지 않음.
    - 이전 트랜잭션이 커밋이 되면 다음 트랜잭션을 실행.
    - 가장 높은 데이터 안정성/가장 낮은 성능

__비일관성 현상__
- Dirty Read : 읽고 롤백하면 쓰레기 값.
- Non-Reapeatable Read : 같은 쿼리로 다른 값을 얻음.
- Phantom Read : 같은 쿼리로 같은 값을 얻지만 실제 값은 다름.

||Read Uncommited|Read Commited|Repeatable Read|Serialize|
|---|----|----|----|----|
|Dirty Read|O|X|X|X|
|Non-Reapeatable Read|O|O|O|X|
|Phantom Read|O|O|O|X|

`MVCC` : 락 없이 읽기 성능을 증가시키는 기술
- 격리 수준이 다를 경우 락이 걸리지 않고 동시에 읽는 것이 가능.
- 동일한 격리 수준의 경우 Undo Log를 동시에 여러개 복제해서 읽기 락 발생 확률을 낮음.
- Oracle과 MySQL은 Undo Segment 기반으로 현재는 대부분의 기술에서 일반화되었다.

## VLDB
: 읽기 / 쓰기 성능 및 저장 용량을 높이기 위한 기술을 총칭

Partitionaing / Sharding / Replication / Backup Aggregation 등을 묶어서 부르는 기술.
RDBMS의 외래키를 지원하지 않아 Join 연산이 안되기에 `역정규화`를 통한 중복이 허용

### 복제(Replication)
- 동일한 데이터베이스를 여러개 생성하여 DB를 다중화하고 장애에 대응함.
- 마스터 / 슬레이브 형태로 DBMS를 구성하며 (마스터-마스터 복제도 존재함) 마스터에 쓰고, 슬레이브에서 읽기를 담당함. 마스터 1대에 슬레이브 8-10대 이하로 구성된다.

__복제 방식__
1. 비동기 복제
    - 슬레이브에 내용이 반영되었는지 확인하지 않음. 속도가 가장 빠르며, 슬레이브의 랙 현상 발생가능.
2. 반동기 복제
    - 슬레이브 중에 하나는 반영되었는지 확인. 신뢰도 중간.
3. 동기 복제
    - 모든 슬레이브가 반영되었는지 확인. 가장 느리지만 신뢰도 높음.

> MySQL Binlog Format
1. Statement-based : 마스터에 들어온 쿼리를 슬레이브에 복사. 동일한 쿼리를 실행해도 다른 결과가 나오는 경우 문제가 발생. ex) Timestamp, Random 난수
2. Row-based : 쿼리가 아닌 쿼리의 실행결과를 슬레이브로 보냄. 동일한 결과를 보장하지만 트래픽이 많아지는 단점 발생.
3. Mixed : 기본은 Statement-based를 사용하고, 상황에 따라 Row-based를 사용하는 방식.

### 파티셔닝(Partitioning)
- B-트리 인덱스의 경우 데이터가 많아지면 트리의 Depth가 깊어짐. 길이가 길어지면 비교횟수가 늘어나면서 검색속도가 느려지거나 해시 인덱스의 경우에는 데이터가 많아지면서 충돌 현상 발생.
- 테이블을 좀 더 작은 파티션으로 분할해서 관리하여. 필요한 파티션만 선별해서 검색.

__종류__
1. 레인지(Range) 파티션 : 연속적인 값을 사용해서 분할 ex) 연도별로 구분
2. 리스트(List) 파티션 : 이산적인 값을 사용해서 분할 ex) 카테고리 류, 계절별, 성별
3. 해쉬(Hash) 파티션 : 해시를 사용해서 분할 -> 짝수/ 홀수 / 나머지 연산
4. 키(Key) 파티션 : PK컬럼이 파티션 키가 됨. 파티션이 추가될때 Global Relocation이 발생.
5. 리니어(Linear) 파티션 : Global Relocation 현상의 완화로 인접 파티션으로 이동만 허용해서 파티션 별로 크기가 달라진다.

__제약조건__
- 동일한 스토리지 엔진.
- 5.6부터 8192개로 확장
- 외래키 사용불가 (Join X)
- 전문검색 인덱스 / R-Tree 인덱스 사용 불가

### 샤딩 (Sharding)
- 여러 대의 시스템에 나눠서 데이터를 저장. 파티션과 유사한 개념.
- 쓰기 성능 향상 : 샤딩의 수와 쓰기 성능이 상관관계를 가짐.

> 파티셔닝 vs 샤딩
> - 파티셔닝은 계속 성능이 좋아지지 않는다.
> - 샤딩은 계속 쓰기 성능이 좋아진다 : 샤드별로 분산 저장 속도가 빨라진다.

__샤딩방법__
- 수평(Horizontal) 샤딩 : Data는 다르지만, 동일한 스키마(전화번호부 방식. a-m / n-r / s-z)
- 수직(Vertical) 샤딩 : 샤드별로 다른 스키마를 가짐.


### NoSQL


### 전문검색()


